# 单页招聘应用项目app【P40~】

### 【2019-8-3  09:26:00】今日计划：P40-P50

## 搭建整体界面

用户注册/登陆并完善信息之后，进入的界面。

功能：

- 底部切换按钮，不同的按钮可一切换到不同的路由组件界面。根据不同的类型，呈现相应的组件页面。

- 实现自动登录的功能【通过cookie实现。cookie当中保存有用户id->userid】。userid通过发送请求得到。

  1.实现自动登录。如果cookie中有userid，就自动登录。要实现自动登录，就需要发请求，获取对应的user
  2.如果cookie中没有userid，就进入login界面。
  3.如果已经登陆了，那么是进入完善信息的路由，还是进入主界面路由。
  如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向

- 主页面项目搭建：在containers/main/main.jsx当中完成
  - 读取cookie中的userid：可原生，也可加载依赖包:

    ```
    sudo cnpm install js-cookie -S
    ```

    js-cookie库提供了一个Cookies对象，这是一个可以操作前端cookie的对象。提供set()/get()/remove()等方法.

    github地址：[js-cookie GitHub地址](https://github.com/js-cookie/js-cookie)

    ```javascript
    //containers/main/main.jsx
    
    import Cookies from "js-cookie";
    import { getRedirectTo } from "../../utils";
    
        //读取cookie中userid
    		const userid = Cookies.get('userid');
    		//如果没有，自动重定向到登陆界面
    		if (!userid) {
    			return <Redirect to="/login" />
    		}
    		//如果有，读取redux中的user状态。
    		const { user } = this.props;
    		//如果redux中user状态里没有_id，不能跳转登陆界面，而是返回一个null，不做任何显示
    		if (!userid) {
    			return null
    		}else{//如果redux中user状态里有_id，显示对应的界面
    			const path = this.props.location.pathname;
    			if (path === '/') {//如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向
    				//得到一个重定向的路由路径
    				getRedirectTo(user.type, user.header);
    				return <Redirect to={} />
    			}
    		}
    
    ```

  用Cookies.get("userid")时报错：

  ![Snip20190803_1](/Users/luofei/Pictures/Snip20190803_1.png)

原因：在main.jsx文件里引入Cookies的时候错误引用了。正确的格式应该是：

```javascript
import Cookies from "js-cookie";
```

服务器端路由：

```javascript
//后端项目文件/routers/index.js

//获取用户信息的路由，根据userid获取
router.get('/user', function(req,res){
	const userid = req.cookies.userid;
	if (!userid) {
		return res.send({code:1, msg:"请先登陆"})
	}
	//根据userid查询对应的user
	UserModel.findOne({_id: userid},filter,function(error,user){
		res.send({code:0, data:user});
	})
})
```

前端api：

```javascript
//前端项目文件/src/api/index

//获取用户信息
export const reqUser = ()=> ajax('/user')
```

获取用户信息的异步action

```javascript
//前端项目文件/src/redux/actions

//获取用户的异步action: getUser()
export const getUser = () => {
	return async dispatch => {
		//执行异步ajax请求
		const response = await reqUser(); //reqUser()是一个ajax请求，请求结果包括{code: xx, data:{}}
		const result = response.data;
		if (result.code === 0) {
			//成功获取数据
			dispatch(receiveUser(result.data));
		}else{
			//获取数据失败
			dispatch(resetUser(result.msg))
		}
	}
}
```

回到前端项目代码/src/containers/main/main.jsx

```javascript
//src/containers/main/main.jsx

import { getUser } from "../../redux/actions"

//组件里的componentDidMount()函数
componentDidMount(){
		const userid = Cookies.get('userid');
		const { _id } = this.props.user;
		if (userid && !_id) { //登陆过，所以有userid；现在没有登陆，所以没有_id
			//发送异步请求，获取user【先写ajax->再写redux->再写这个组件】
			this.props.getUser() //不需要传入参数
		}
	}

export default connect(
	state => ({user: state.user}),
	{ getUser } //将getUser传到当前的UI组件
	)(Main)

```

前端路由组件。一般都要跟redux交互，所以一般都放在containers文件夹里。

- 创建四个需要和redux交互的文件夹：
  - containers/laoban/laoban.jsx
  - containers/dashen/dashen.jsx
  - containers/message/message.jsx
  - containers/personal/personal.jsx

- 404界面。这个界面不需要跟redux交互。
  - components/not-found

首先写404界面：

```javascript
//404页面，找不到页面的时候返回到这里。

import React, {Component} from "react";
import { Button } from "antd-mobile"

//大神界面路由容器主
class NotFound extends Component{
	render(){
		return (
			<div>
				<div>
					<h2>抱歉，找不到该页面！</h2>
					<Button type="primary" 
					onClick={ ()=>this.props.history.replace('/') }>回到首页</Button>
				</div>
			</div>
			)
	}
}

export default connect(
	state => ({}),
	{}
	)(NotFound)
```

再将其映射到main.jsx文件当中

```javascript
//containers/main/main.jsx
import Dashen from "../dashen/dashen";
import Laoban from "../laoban/laoban";
import Message from "../message/message";
import Personal from "../personal/personal";
import NotFound from "../../components/not-found/not-found";

...

<Switch>
				<Route path="/dasheninfo" component={ DashenInfo } />
				<Route path="/laobaninfo" component={ LaobanInfo } />
				<Route component={ Laoban } />
</Switch>
```

每个路由里包含里五部分信息：路由路径、路由组件、底部对应的图标、图标对应的文字、顶部标题，老板/大神的这五个部分信息不同，其它部分界面组成相同。

- 在main.jsx里引入这部分信息

```javascript
class Main extends Component{
	//不加static是给组件对象添加属性，加static是给组件类添加属性
	navList = [ //包含所有导航组件的相关数据信息。
	{
		path: "/laoban",
		component: Laoban,
		title: "大神列表",
		icon: "dashen", //
		text: "大神"
	},
	{
		path:"/dashen",
		component: Dashen,
		title: "老板列表",
		icon: "laoban",
		text: "老板"
	},
	{
		path: "/message",
		component: Message,
		title:"消息列表",
		icon: "message",
		text: "消息"
	},
	{
		path: "/personal",
		component: Personal,
		title: "用户中心",
		icon: "personal",
		text: "个人"
	}
	]
```

- 映射路由

  每个main路由下面的子路由都是上、中、下的结构，包括顶部标题、中间是四个导航路由组件显示的部分，底部

```javascript
	const  { navList }= this;
		const path = this.props.location.pathname;//请求的路径
		const currentNav = navList.find(nav => nav.path === path) //数组查找元素用find()方法.navList当中的每一个元素都是一个nav，我们需要对比nav下的path是不是等于当前的path 
		//find()中如果为true，得到首个匹配项。
		return (<div>
					{ currentNav ? <NavBar>{ currentNav.title }</NavBar> : null}
					<Switch>
					{
						navList.map(nav => <Route path={nav.path} component={nav.component} />) //映射了四个路由
					}
						<Route path="/dasheninfo" component={ DashenInfo } />
						<Route path="/laobaninfo" component={ LaobanInfo } />
						<Route component={ Laoban } />
					</Switch>
					{ currentNav ? <div></div> : null} {/*<div></div>暂时占位，这是底部导航，需要单独抽取出来。*/}
				</div>)
```

- 定义底部导航【底部导航不需要和redux进行交互】

  - 定义在components/nav-footer/nav-footer.jsx

  - ⚠️const path = this.props.location.pathname：路由组件才有这个写法，nav-footer.jsx组件是非路由组件，因此path不能用这个方式获取。
  - 如果希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，它可以对当前组件进行包装，返回包装后的组件。

  ```javascript
  //components/nav-footer/nav-footer.jsx
  
  import React, { Component } from "react";
  import { TabBar } from "antd-mobile";
  import PropTypes from "prop-types";
  import { withRouter } from "react-router-dom";
  
  const Item = TabBar.Item
  
  //底部容器
  class NavFooter extends Component{
  	static propTypes = {
  		navList: PropTypes.array.isRequired
  	}
  	render(){
  		const { navList } = this.props;
  		const path = this.props.location.pathname; //路由组件才有这个写法，这个组件是路由组件，因此path不能用这个方式获取
  		//希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，
  		//对当前组件进行包装，返回包装后的组件
  		return (
  			<TabBar >{ navList.map((nav) => (
  				<Item 
  				key={nav.path}
  				title={nav.text}
  				icon={{uri:require(`./images/${nav.icon}.png`)}} 
  				//第一层{}表示要写js表达式，第二层{}表示要写对象，``表示写的是一个模版字符串
  				selectedIcon={{uri:require(`./images/${nav.icon}-selected.png`)}}
  				selected={ path === nav.path}
  				onPress={()=>this.props.history.replace(nav.path)}
  				tabBarPosition="bottom"></Item>
  				)
  			)
  		}</TabBar>)
  	}
  }
  
  //内部会向组件中传入一些路由组件特有的属性：history/location/math
  export default withRouter(NavFooter); //向外暴露withRouter()包装产生的组件
  ```

  main中保存了四个二级路由，但有一个组件需要被动态隐藏。给其中一个组件添加隐藏信息。哪个组件被隐藏根据用户类型决定。如果当前用户类型是“laoban”，那么就隐藏“dashen”组件。

  nav-footer.jsx组件用withRouter包装并导出，可用props接收父组件的属性

  ```javascript
  //nav-footer.jsx
  
  let { navList } = this.props; //从父组件当中获取navList
  //过滤掉hide为true的nav
  navList = navList.filter(nav => !nav.hide)
  ```

  #### 个人中心功能页面的编写：containers/personal/personal.jsx

  - 使用antd-mobile里的UI组件

    ```javascript
    import { Result, List, Button, WhiteSpace } from "antd-mobile";
    ```

  - 用connect将组件包装成容器组件

    ```javascript
    export default connect(
    	state => ({user: state.user}),
    	{}
    	)(Personal);
    ```

  - 页面结构：

    ```javascript
    class Personal extends Component{
    	render(){
    		const { username, header, company, post, salary, info } = this.props.user
    		return (
    			<div>
    				<Result 
    					img={<img src={require(`../../assets/images/${header}.png`)} style={{width:50}} alt="header"/>} title={username} message={company} />
    				<List renderHeader={ ()=> "相关信息" }>
    					<Item multipleLine> 
    						<Brief>职位：{post}</Brief>
    						<Brief>简介：{info}</Brief>
    						{salary ? <Brief>薪资：{salary}</Brief> : null}
    					</Item>
    				</List>
    				<WhiteSpace/>
    				<List>
    					<Button type="warning">退出登录</Button>
    				</List>
    			</div>)
    	}
    }
    ```

  - 退出登录功能的编写

    ```
    <Button type="warning" onClick={this.loginOut}>退出登录</Button>
    ```

    ❌：点击“退出”按钮时，按钮没有样式上的任何反应。

    📓：原因是底部导航的高度100%，覆盖了整个页面。导致点击不到退出按钮。

    📒：解决办法：需要修改assets/css/index.less文件里的`.am-tab-bar`样式，设置`height:inherit;`

  - 要实现点击“退出登录”按钮，跳出确认框，跳转到登陆界面上的功能，需要一个对话框组件：Modal。Modal组件由antd-mobile提供，它是一个对象，不是一个标签。Modal组件有一个alert方法，接收三个参数，Modal.alert("退出", "确认退出登录吗？", [{},{}])，前两个是描述，第三个是一个数组，数组第一个元素描述第一个按钮，第二个元素描述第二个按钮。

  - 如果不需要跟后台通信，那么就用同步action。resetuser可以使用户状态回到初始状态。

    ```javascript
    logOut = ()=>{
    		Modal.alert("退出", "确认退出登录吗？", [
    			{
    				text: "取消",
    			},
    			{
    				text: "确认",
    				onPress : ()=>{
    					//移除cookie中的userid
    					Cookies.remove("userid");
    					//移除redux里管理的userid
    					this.props.resetUser()
    				}
    			}])
    	}
    ```

  ✅：“个人中心”路由界面的代码编写完成

#### 老板/大神列表功能的编写containers/laoban/laoban.jsx; 

#### containers/dashen/dashen.jsx 

两个列表功能类似，可以抽取出一个组件，用来展示相同的结构。只要根据类别往里面填充不同功能就可以了。因此我们创建一个用户列表组件：components/user-list/user-list.jsx

- 需要编写展示大神/老板列表的静态UI组件。需求：从后台获取指定用户类型的列表，渲染到页面上

- 首先编写后台路由routes/index.js

- ```javascript
  //根据type获取对应的用户列表
  router.get('/userlist',function(req,res){
  	const { type } = req.query;
  	UserModel.find({type}, filter, function(error, users){
  		res.send({code: 0, data: users});
  	})
  })
  ```

- 后台路由编写好之后，在postman进行接口的调试。选择“GET”类型，“params”类型进行测试。

  ✅：展示大神/老板列表的后台路由接口编写完成，功能为根据type获取对应的用户列表

  ------

- 前台api的编写。根据接口文档去定义接口请求函数

  ```javascript
  //src/api/index.js
  export const reqUserList = (type)=> ajax("/userlist", {type}, "GET");//请求方式为"GET"时可省略
  ```

- userList需要用redux进行管理，因此需要编写redux

  ```javascript
  //action-types
  export const RECEIVE_USER_LIST = "receive_user_list";
  //之前的action都是在操作user，此action是操作user-list 的，因此需要定义对应的reducer
  ```

  ```javascript
  //reducer
  //产生userlist状态的reducer
  const initUserList = []
  function userList(state=initUserList, action){
  	switch(action.type){
  		case REVEIVE_USER_LIST: //data为userList
  		return action.data
  		default:
  		return state
  	}
  }
  ```

  ```javascript
  //action
  
  //接收用户列表的同步action
  export const receiveUserList = (userList)=>({type: REVEIVE_USER_LIST, data: userList});
  
  //获取用户列表的异步action
  //获取用户列表的异步action
  export const getUserList = (type)=>{
  	return async dispatch =>{
  		//执行异步ajax请求
  		const response = await reqUserList(type)
  		const result = response.data;
  		//得到结果之后分发一个同步action
  		if (result.code === 0) {
  			dispatch(receiveUserList(result.data));
  		}
  	}
  }
  ```

  ✅：获取用户列表的redux部分代码完成

  ------

  