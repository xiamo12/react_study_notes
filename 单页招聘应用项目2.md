

# 单页招聘应用项目app【P40~】

### 【2019-8-3  09:26:00】今日计划：P40-P50

[TOC]



## 搭建整体界面

## 用户注册/登陆并完善信息之后，进入的界面。

功能：

- 底部切换按钮，不同的按钮可一切换到不同的路由组件界面。根据不同的类型，呈现相应的组件页面。

- 实现自动登录的功能【通过cookie实现。cookie当中保存有用户id->userid】。userid通过发送请求得到。

  1.实现自动登录。如果cookie中有userid，就自动登录。要实现自动登录，就需要发请求，获取对应的user
  2.如果cookie中没有userid，就进入login界面。
  3.如果已经登陆了，那么就判断是进入完善信息的路由，还是进入主界面路由。
  如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向

- 主页面项目搭建：在containers/main/main.jsx当中完成

  - 读取cookie中的userid：可原生，也可加载依赖包:

    ```
    sudo cnpm install js-cookie -S
    ```

    js-cookie库提供了一个Cookies对象，这是一个可以操作前端cookie的对象。提供set()/get()/remove()等方法.

    github地址：[js-cookie GitHub地址](https://github.com/js-cookie/js-cookie)

    ```javascript
    //containers/main/main.jsx
    
    import Cookies from "js-cookie";
    import { getRedirectTo } from "../../utils";
    
        //读取cookie中userid
    		const userid = Cookies.get('userid');
    		//如果没有，自动重定向到登陆界面
    		if (!userid) {
    			return <Redirect to="/login" />
    		}
    		//如果有，读取redux中的user状态。
    		const { user } = this.props;
    		//如果redux中user状态里没有_id，不能跳转登陆界面，而是返回一个null，不做任何显示
    		if (!userid) {
    			return null
    		}else{//如果redux中user状态里有_id，显示对应的界面
    			const path = this.props.location.pathname;
    			if (path === '/') {//如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向
    				//得到一个重定向的路由路径
    				getRedirectTo(user.type, user.header);
    				return <Redirect to={} />
    			}
    		}
    
    ```

  用Cookies.get("userid")时报错：

  ![Snip20190803_1](/Users/luofei/Pictures/Snip20190803_1.png)

原因：在main.jsx文件里引入Cookies的时候错误引用了。正确的格式应该是：

```javascript
import Cookies from "js-cookie";
```

✅：主界面的编写完成。

### 服务器端路由：

```javascript
//后端项目文件/routers/index.js

//获取用户信息的路由，根据userid获取
router.get('/user', function(req,res){
	const userid = req.cookies.userid;
	if (!userid) {
		return res.send({code:1, msg:"请先登陆"})
	}
	//根据userid查询对应的user
	UserModel.findOne({_id: userid}, filter, function(error,user){
		res.send({code:0, data:user});
	})
})
```

### 前端api：

```javascript
//前端项目文件/src/api/index

//获取用户信息
export const reqUser = ()=> ajax('/user')
```

### 获取用户信息的异步action

```javascript
//前端项目文件/src/redux/actions

//获取用户的异步action: getUser()
export const getUser = () => {
	return async dispatch => {
		//执行异步ajax请求
		const response = await reqUser(); //reqUser()是一个ajax请求，请求结果包括{code: xx, data:{}}
		const result = response.data;
		if (result.code === 0) {
			//成功获取数据
			dispatch(receiveUser(result.data));
		}else{
			//获取数据失败
			dispatch(resetUser(result.msg))
		}
	}
}
```

### 回到前端项目代码/src/containers/main/main.jsx

```javascript
//src/containers/main/main.jsx

import { getUser } from "../../redux/actions"

//组件里的componentDidMount()函数
componentDidMount(){
		const userid = Cookies.get('userid');
		const { _id } = this.props.user;
		if (userid && !_id) { //登陆过，所以有userid；现在没有登陆，所以没有_id
			//发送异步请求，获取user【先写ajax->再写redux->再写这个组件】
			this.props.getUser() //不需要传入参数
		}
	}

export default connect(
	state => ({user: state.user}),
	{ getUser } //将getUser传到当前的UI组件
	)(Main)

```

### 前端路由组件。

一般都要跟redux交互，所以一般都放在containers文件夹里。

- 创建四个需要和redux交互的文件夹：
  - containers/laoban/laoban.jsx
  - containers/dashen/dashen.jsx
  - containers/message/message.jsx
  - containers/personal/personal.jsx

- 404界面。这个界面不需要跟redux交互。
  - components/not-found

首先写404界面：

```javascript
//404页面，找不到页面的时候返回到这里。

import React, {Component} from "react";
import { Button } from "antd-mobile"

//大神界面路由容器主
export default class NotFound extends Component{
	render(){
		return (
			<div>
				<div>
					<h2>抱歉，找不到该页面！</h2>
					<Button type="primary" 
					onClick={ ()=>this.props.history.replace('/') }>回到首页</Button>
				</div>
			</div>
			)
	}
}
```

再将其映射到main.jsx文件当中

```javascript
//containers/main/main.jsx
import Dashen from "../dashen/dashen";
import Laoban from "../laoban/laoban";
import Message from "../message/message";
import Personal from "../personal/personal";
import NotFound from "../../components/not-found/not-found";

...

<Switch>
				<Route path="/dasheninfo" component={ DashenInfo } />
				<Route path="/laobaninfo" component={ LaobanInfo } />
				<Route component={ Laoban } />
</Switch>
```

每个路由里包含里五部分信息：路由路径、路由组件、底部对应的图标、图标对应的文字、顶部标题，老板/大神的这五个部分信息不同，其它部分界面组成相同。

- 在main.jsx里引入这部分信息

```javascript
class Main extends Component{
	//不加static是给组件对象添加属性，加static是给组件类添加属性
	navList = [ //包含所有导航组件的相关数据信息。
	{
		path: "/laoban",
		component: Laoban,
		title: "大神列表",
		icon: "dashen", //
		text: "大神"
	},
	{
		path:"/dashen",
		component: Dashen,
		title: "老板列表",
		icon: "laoban",
		text: "老板"
	},
	{
		path: "/message",
		component: Message,
		title:"消息列表",
		icon: "message",
		text: "消息"
	},
	{
		path: "/personal",
		component: Personal,
		title: "用户中心",
		icon: "personal",
		text: "个人"
	}
	]
```

- 映射路由

  每个main路由下面的子路由都是上、中、下的结构，包括顶部标题、中间是四个导航路由组件显示的部分，底部

```javascript
	const  { navList }= this;
		const path = this.props.location.pathname;//请求的路径
		const currentNav = navList.find(nav => nav.path === path) //数组查找元素用find()方法.navList当中的每一个元素都是一个nav，我们需要对比nav下的path是不是等于当前的path 
		//find()中如果为true，得到首个匹配项。
		return (<div>
					{ currentNav ? <NavBar>{ currentNav.title }</NavBar> : null}
					<Switch>
					{
						navList.map(nav => <Route path={nav.path} component={nav.component} />) //映射了四个路由
					}
						<Route path="/dasheninfo" component={ DashenInfo } />
						<Route path="/laobaninfo" component={ LaobanInfo } />
						<Route component={ Laoban } />
					</Switch>
					{ currentNav ? <div></div> : null} {/*<div></div>暂时占位，这是底部导航，需要单独抽取出来。*/}
				</div>)
```

- 定义底部导航【底部导航不需要和redux进行交互】

  - 定义在components/nav-footer/nav-footer.jsx

  - ⚠️const path = this.props.location.pathname：路由组件才有这个写法，nav-footer.jsx组件是非路由组件，因此path不能用这个方式获取。
  - 如果希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，它可以对当前组件进行包装，返回包装后的组件。

  ```javascript
  //components/nav-footer/nav-footer.jsx
  
  import React, { Component } from "react";
  import { TabBar } from "antd-mobile";
  import PropTypes from "prop-types";
  import { withRouter } from "react-router-dom";
  
  const Item = TabBar.Item
  
  //底部容器
  class NavFooter extends Component{
  	static propTypes = {
  		navList: PropTypes.array.isRequired
  	}
  	render(){
  		const { navList } = this.props;
  		const path = this.props.location.pathname; //路由组件才有这个写法，这个组件是路由组件，因此path不能用这个方式获取
  		//希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，
  		//对当前组件进行包装，返回包装后的组件
  		return (
  			<TabBar >{ navList.map((nav) => (
  				<Item 
  				key={nav.path}
  				title={nav.text}
  				icon={{uri:require(`./images/${nav.icon}.png`)}} 
  				//第一层{}表示要写js表达式，第二层{}表示要写对象，``表示写的是一个模版字符串
  				selectedIcon={{uri:require(`./images/${nav.icon}-selected.png`)}}
  				selected={ path === nav.path}
  				onPress={()=>this.props.history.replace(nav.path)}
  				tabBarPosition="bottom"></Item>
  				)
  			)
  		}</TabBar>)
  	}
  }
  
  //内部会向组件中传入一些路由组件特有的属性：history/location/math
  export default withRouter(NavFooter); //向外暴露withRouter()包装产生的组件
  ```

  main中保存了四个二级路由，但有一个组件需要被动态隐藏。给其中一个组件添加隐藏信息。哪个组件被隐藏根据用户类型决定。如果当前用户类型是“laoban”，那么就隐藏“dashen”组件。

  nav-footer.jsx组件用withRouter包装并导出，可用props接收父组件的属性

  ```javascript
  //nav-footer.jsx
  
  let { navList } = this.props; //从父组件当中获取navList
  //过滤掉hide为true的nav
  navList = navList.filter(nav => !nav.hide)
  ```

## 个人中心功能页面的编写：

containers/personal/personal.jsx

- 使用antd-mobile里的UI组件

  ```javascript
  import { Result, List, Button, WhiteSpace } from "antd-mobile";
  ```

- 用connect将组件包装成容器组件

  ```javascript
  export default connect(
  	state => ({user: state.user}),
  	{}
  	)(Personal);
  ```

- 页面结构：

  ```javascript
  class Personal extends Component{
  	render(){
  		const { username, header, company, post, salary, info } = this.props.user
  		return (
  			<div>
  				<Result 
  					img={<img src={require(`../../assets/images/${header}.png`)} style={{width:50}} alt="header"/>} title={username} message={company} />
  				<List renderHeader={ ()=> "相关信息" }>
  					<Item multipleLine> 
  						<Brief>职位：{post}</Brief>
  						<Brief>简介：{info}</Brief>
  						{salary ? <Brief>薪资：{salary}</Brief> : null}
  					</Item>
  				</List>
  				<WhiteSpace/>
  				<List>
  					<Button type="warning">退出登录</Button>
  				</List>
  			</div>)
  	}
  }
  ```

- 退出登录功能的编写

  ```
  <Button type="warning" onClick={this.loginOut}>退出登录</Button>
  ```

  ❌：点击“退出”按钮时，按钮没有样式上的任何反应。

  📓：原因是底部导航的高度100%，覆盖了整个页面。导致点击不到退出按钮。

  📒：解决办法：需要修改assets/css/index.less文件里的`.am-tab-bar`样式，设置`height:inherit;`

- 要实现点击“退出登录”按钮，跳出确认框，跳转到登陆界面上的功能，需要一个对话框组件：Modal。Modal组件由antd-mobile提供，它是一个对象，不是一个标签。Modal组件有一个alert方法，接收三个参数，Modal.alert("退出", "确认退出登录吗？", [{},{}])，前两个是描述，第三个是一个数组，数组第一个元素描述第一个按钮，第二个元素描述第二个按钮。

- 如果不需要跟后台通信，那么就用同步action。resetuser可以使用户状态回到初始状态。

  ```javascript
  logOut = ()=>{
  		Modal.alert("退出", "确认退出登录吗？", [
  			{
  				text: "取消",
  			},
  			{
  				text: "确认",
  				onPress : ()=>{
  					//移除cookie中的userid
  					Cookies.remove("userid");
  					//移除redux里管理的userid
  					this.props.resetUser()
  				}
  			}])
  	}
  ```

✅：“个人中心”路由界面的代码编写完成

## 老板/大神列表功能的编写

containers/laoban/laoban.jsx; 

#### containers/dashen/dashen.jsx 

两个列表功能类似，可以抽取出一个组件，用来展示相同的结构。只要根据类别往里面填充不同功能就可以了。因此我们创建一个用户列表组件：components/user-list/user-list.jsx

- 需要编写展示大神/老板列表的静态UI组件。需求：从后台获取指定用户类型的列表，渲染到页面上

- 首先编写后台路由routes/index.js

- ```javascript
  //根据type获取对应的用户列表
  router.get('/userlist',function(req,res){
  	const { type } = req.query;
  	UserModel.find({type}, filter, function(error, users){
  		res.send({code: 0, data: users});
  	})
  })
  ```

- 后台路由编写好之后，在postman进行接口的调试。选择“GET”类型，“params”类型进行测试。

  ✅：展示大神/老板列表的后台路由接口编写完成，功能为根据type获取对应的用户列表

  ------

- 前台api的编写。根据接口文档去定义接口请求函数

  ```javascript
  //src/api/index.js
  export const reqUserList = (type)=> ajax("/userlist", {type}, "GET");//请求方式为"GET"时可省略
  ```

- userList需要用redux进行管理，因此需要编写redux

  ```javascript
  //action-types
  export const RECEIVE_USER_LIST = "receive_user_list";
  //之前的action都是在操作user，此action是操作user-list 的，因此需要定义对应的reducer
  ```

  ```javascript
  //reducer
  //产生userlist状态的reducer
  //通过dispatch对应的action来修改状态，而状态的修改统一通过reducer来完成。
  const initUserList = []
  function userList(state=initUserList, action){
  	switch(action.type){
  		case REVEIVE_USER_LIST: //data为userList
        return action.data
  		default:
  		return state
  	}
  }
  ```

  ```javascript
  //action
  
  //接收用户列表的同步action
  export const receiveUserList = (userList)=>({type: REVEIVE_USER_LIST, data: userList});
  
  //获取用户列表的异步action
  export const getUserList = (type)=>{
  	return async dispatch =>{
  		//执行异步ajax请求
  		const response = await reqUserList(type) //reqUserList是一个ajax请求
  		const result = response.data;//response是一个对象，格式为{code: 0, data: users}
  		//得到结果之后分发一个同步action
  		if (result.code === 0) {
  			dispatch(receiveUserList(result.data));
  		}
  	}
  }
  ```

  ✅：获取用户列表的redux部分代码完成

  ------

  ### 【2019-8-4 09:09:00】

  项目打开流程：

  ```
  数据库mongodb，执行mongod命令；
  后端应用项目，执行 npm start 命令
  前端应用项目，执行 npm start 命令
  ```

- 两个用户列表组件：老板/大神，根据type定义不同列表。但是列表结构是一样的，所以可以抽象成一个组件。

  - 新建componnets/users-list/user-list.jsx

    ```javascript
    //显示指定用户列表的UI组件
    //需要接收一个user-list对象
    import React, { Component } from "react";
    // import { connect } from "react-redux";
    import PropTypes from "prop-types";
    import { WingBlank, Card, WhiteSpace } from "antd-mobile";
    const Header = Card.Header;
    const Body = Card.Body;
    
    export default class UserList extends Component{
    	static propTypes = {
    		userList: PropTypes.array.isRequired //接收一个userList
    	}
    	render(){
    		const { userList } =this.props;
    		return (
    			<WingBlank>
    			{ userList.map(user =>(
    				<div key={user._id}>
    					<WhiteSpace />
    
    					<Card>
    						<Header thumb={require(`../../assets/images/${user.header}.png`)} extra="username"></Header>
    						<Body>
    							<div>职位：{user.post}</div>
    							{user.company ? <div>公司：{user.company}</div> : null}
    							{user.salary ? <div>月薪：{user.salary}</div> : null}
    							<div>描述：{user.info}</div>
    						</Body>
    					</Card>
    				</div>
    				)
    			)}
    			</WingBlank>
    			)
    	}
    }
    ```

    渲染界面的时候遇到bug：![Snip20190804_2](/Users/luofei/Pictures/Snip20190804_2.png)

报错：![Snip20190804_3](/Users/luofei/Pictures/Snip20190804_3.png)

最后发现是在api/ajax.js文件中的substring方法拼写错误，写成了subString了。

【2019-8-4 13:20:00】

✅ bug修复

### 完善列表页面显示:

❌：最后一行的显示会被底部导航栏挡住。

📓：给列表所在tag加style：

```html
<WingBlank style={{marginBottom: 50}}>
```

❌头部会随着页面滚动而滚动，我们需要它固定.加style={{marginBottm:50, marginTop:50}}即可解决问题

✅： 信息列表完成

### 实现实时聊天功能

1. 下载相关依赖包：前台应用和后台应用都需要下载

   ```
   $ sudo cnpm install socket.io -S
   ```

   - 这是一个能实现多人远程实时通信【聊天】的库;

   - 它包装的是H5 WebSocket【涉及到ws协议，语法ws://。http协议只能客户端发起请求，不能实现服务器向浏览器发送请求。ws协议可以实现客户端和服务端互相发送请求】和轮询【浏览器每隔一段时间向服务器发送请求】, 如果是较新的浏览器内部使用WebSocket。

     如果浏览器不支持, 那内部就会使用轮询实现实时通信 

2.  服务器端创建一个测试文件socketIO/test.js

   服务器端的io是全局的，关联很多socket

   ```javascript
   //   /socketIO/test.js
   module.exports = function (server){
   	//得到IO对象
   	const io = require('socket.io')(server); //引用socket.io库，执行server函数得到io
   	//见识连接（当有一个客户连接上时回调）
   	io.on('connection', function(socket){ //这里的on连接任何浏览器：客户端产生连接的时候执行回调函数
   		console.log('socketio connected');
   		//绑定sendMsg监听，接收客户端发送的消息
   		socket.on('sendMsg', function(data){ //on连接的是某一个浏览器，这里的sendMsg可以任意命名
   			console.log('服务器接收到浏览器的消息', data);
   			//向客户端发送消息（名称，数据）
   			io.emit('receiveMsg', data.name+'_'+data.data);//发送给所有连接上服务器的客户端
   			//socket.emit('receiveMsg', data.name+'_'+data.data) 发送给当前socket对应的客户端
         console.log('服务器向浏览器发送消息',data);
   		})
   	})
   }
   
   //这是一个函数类型的模块
   ```

3. 服务端的bin/www文件下：

   ```
   //是一个函数类型
   require('../socketIO/test')(server);
   ```

4. 客户端 src/test/socketio_test.js

   ```javascript
   //此模块没有向外暴露什么，执行它就行了，要想让它执行，可以引入到入口js文件上
   import io from "socket.io-client";
   
   const socket = io('ws://localhost:4000');
   socket.on('receiveMsg', function(data){
   	console.log('浏览器端接收到消息',data);
   });
   
   socket.emit('sendMsg', {name: 'Tom', data: Date.now()});
   console.log('浏览器端向服务器发送消息:', {name: 'Tom', data:Date.now()})
   ```

5. socketio_test模块没有向外暴露，因此想要执行，可以直接在入口js文件里引用

   ```javascript
   //src/index.js
   import "./test/socketio_test";
   ```

