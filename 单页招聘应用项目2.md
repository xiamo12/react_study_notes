# 单页招聘应用项目app【P40~】

### 【2019-8-3  09:26:00】今日计划：P40-P50

[TOC]



## 搭建整体界面

## 用户注册/登陆并完善信息之后，进入的界面。

功能：

- 底部切换按钮，不同的按钮可一切换到不同的路由组件界面。根据不同的类型，呈现相应的组件页面。

- 实现自动登录的功能【通过cookie实现。cookie当中保存有用户id->userid】。userid通过发送请求得到。

  1.实现自动登录。如果cookie中有userid，就自动登录。要实现自动登录，就需要发请求，获取对应的user
  2.如果cookie中没有userid，就进入login界面。
  3.如果已经登陆了，那么就判断是进入完善信息的路由，还是进入主界面路由。
  如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向

- 主页面项目搭建：在containers/main/main.jsx当中完成

  - 读取cookie中的userid：可原生，也可加载依赖包:

    ```
    sudo cnpm install js-cookie -S
    ```

    js-cookie库提供了一个Cookies对象，这是一个可以操作前端cookie的对象。提供set()/get()/remove()等方法.

    github地址：[js-cookie GitHub地址](https://github.com/js-cookie/js-cookie)

    ```javascript
    //containers/main/main.jsx
    
    import Cookies from "js-cookie";
    import { getRedirectTo } from "../../utils";
    
        //读取cookie中userid
    		const userid = Cookies.get('userid');
    		//如果没有，自动重定向到登陆界面
    		if (!userid) {
    			return <Redirect to="/login" />
    		}
    		//如果有，读取redux中的user状态。
    		const { user } = this.props;
    		//如果redux中user状态里没有_id，不能跳转登陆界面，而是返回一个null，不做任何显示
    		if (!userid) {
    			return null
    		}else{//如果redux中user状态里有_id，显示对应的界面
    			const path = this.props.location.pathname;
    			if (path === '/') {//如果请求根路径，就根据type和header来计算出一个重定向的路径，自动重定向
    				//得到一个重定向的路由路径
    				getRedirectTo(user.type, user.header);
    				return <Redirect to={} />
    			}
    		}
    
    ```

  用Cookies.get("userid")时报错：

  ![Snip20190803_1](/Users/luofei/Pictures/Snip20190803_1.png)

原因：在main.jsx文件里引入Cookies的时候错误引用了。正确的格式应该是：

```javascript
import Cookies from "js-cookie";
```

✅：主界面的编写完成。

### 服务器端路由：

```javascript
//后端项目文件/routers/index.js

//获取用户信息的路由，根据userid获取
router.get('/user', function(req,res){
	const userid = req.cookies.userid;
	if (!userid) {
		return res.send({code:1, msg:"请先登陆"})
	}
	//根据userid查询对应的user
	UserModel.findOne({_id: userid}, filter, function(error,user){
		res.send({code:0, data:user});
	})
})
```

### 前端api：

```javascript
//前端项目文件/src/api/index

//获取用户信息
export const reqUser = ()=> ajax('/user')
```

### 获取用户信息的异步action

```javascript
//前端项目文件/src/redux/actions

//获取用户的异步action: getUser()
export const getUser = () => {
	return async dispatch => {
		//执行异步ajax请求
		const response = await reqUser(); //reqUser()是一个ajax请求，请求结果包括{code: xx, data:{}}
		const result = response.data;
		if (result.code === 0) {
			//成功获取数据
			dispatch(receiveUser(result.data));
		}else{
			//获取数据失败
			dispatch(resetUser(result.msg))
		}
	}
}
```

### 回到前端项目代码/src/containers/main/main.jsx

```javascript
//src/containers/main/main.jsx

import { getUser } from "../../redux/actions"

//组件里的componentDidMount()函数
componentDidMount(){
		const userid = Cookies.get('userid');
		const { _id } = this.props.user;
		if (userid && !_id) { //登陆过，所以有userid；现在没有登陆，所以没有_id
			//发送异步请求，获取user【先写ajax->再写redux->再写这个组件】
			this.props.getUser() //不需要传入参数
		}
	}

export default connect(
	state => ({user: state.user}),
	{ getUser } //将getUser传到当前的UI组件
	)(Main)

```

### 前端路由组件。

一般都要跟redux交互，所以一般都放在containers文件夹里。

- 创建四个需要和redux交互的文件夹：
  - containers/laoban/laoban.jsx
  - containers/dashen/dashen.jsx
  - containers/message/message.jsx
  - containers/personal/personal.jsx

- 404界面。这个界面不需要跟redux交互。
  - components/not-found

首先写404界面：

```javascript
//404页面，找不到页面的时候返回到这里。

import React, {Component} from "react";
import { Button } from "antd-mobile"

//大神界面路由容器主
export default class NotFound extends Component{
	render(){
		return (
			<div>
				<div>
					<h2>抱歉，找不到该页面！</h2>
					<Button type="primary" 
					onClick={ ()=>this.props.history.replace('/') }>回到首页</Button>
				</div>
			</div>
			)
	}
}
```

再将其映射到main.jsx文件当中

```javascript
//containers/main/main.jsx
import Dashen from "../dashen/dashen";
import Laoban from "../laoban/laoban";
import Message from "../message/message";
import Personal from "../personal/personal";
import NotFound from "../../components/not-found/not-found";

...

<Switch>
				<Route path="/dasheninfo" component={ DashenInfo } />
				<Route path="/laobaninfo" component={ LaobanInfo } />
				<Route component={ Laoban } />
</Switch>
```

每个路由里包含里五部分信息：路由路径、路由组件、底部对应的图标、图标对应的文字、顶部标题，老板/大神的这五个部分信息不同，其它部分界面组成相同。

- 在main.jsx里引入这部分信息

```javascript
class Main extends Component{
	//不加static是给组件对象添加属性，加static是给组件类添加属性
	navList = [ //包含所有导航组件的相关数据信息。
	{
		path: "/laoban",
		component: Laoban,
		title: "大神列表",
		icon: "dashen", //
		text: "大神"
	},
	{
		path:"/dashen",
		component: Dashen,
		title: "老板列表",
		icon: "laoban",
		text: "老板"
	},
	{
		path: "/message",
		component: Message,
		title:"消息列表",
		icon: "message",
		text: "消息"
	},
	{
		path: "/personal",
		component: Personal,
		title: "用户中心",
		icon: "personal",
		text: "个人"
	}
	]
```

- 映射路由

  每个main路由下面的子路由都是上、中、下的结构，包括顶部标题、中间是四个导航路由组件显示的部分，底部

```javascript
	const  { navList }= this;
		const path = this.props.location.pathname;//请求的路径
		const currentNav = navList.find(nav => nav.path === path) //数组查找元素用find()方法.navList当中的每一个元素都是一个nav，我们需要对比nav下的path是不是等于当前的path 
		//find()中如果为true，得到首个匹配项。
		return (<div>
					{ currentNav ? <NavBar>{ currentNav.title }</NavBar> : null}
					<Switch>
					{
						navList.map(nav => <Route path={nav.path} component={nav.component} />) //映射了四个路由
					}
						<Route path="/dasheninfo" component={ DashenInfo } />
						<Route path="/laobaninfo" component={ LaobanInfo } />
						<Route component={ Laoban } />
					</Switch>
					{ currentNav ? <div></div> : null} {/*<div></div>暂时占位，这是底部导航，需要单独抽取出来。*/}
				</div>)
```

- 定义底部导航【底部导航不需要和redux进行交互】

  - 定义在components/nav-footer/nav-footer.jsx

  - ⚠️const path = this.props.location.pathname：路由组件才有这个写法，nav-footer.jsx组件是非路由组件，因此path不能用这个方式获取。
  - 如果希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，它可以对当前组件进行包装，返回包装后的组件。

  ```javascript
  //components/nav-footer/nav-footer.jsx
  
  import React, { Component } from "react";
  import { TabBar } from "antd-mobile";
  import PropTypes from "prop-types";
  import { withRouter } from "react-router-dom";
  
  const Item = TabBar.Item
  
  //底部容器
  class NavFooter extends Component{
  	static propTypes = {
  		navList: PropTypes.array.isRequired
  	}
  	render(){
  		const { navList } = this.props;
  		const path = this.props.location.pathname; //路由组件才有这个写法，这个组件是路由组件，因此path不能用这个方式获取
  		//希望在非路由组件中使用路由库的api，可以使用路由组件库的一个函数withRoute()，
  		//对当前组件进行包装，返回包装后的组件
  		return (
  			<TabBar >{ navList.map((nav) => (
  				<Item 
  				key={nav.path}
  				title={nav.text}
  				icon={{uri:require(`./images/${nav.icon}.png`)}} 
  				//第一层{}表示要写js表达式，第二层{}表示要写对象，``表示写的是一个模版字符串
  				selectedIcon={{uri:require(`./images/${nav.icon}-selected.png`)}}
  				selected={ path === nav.path}
  				onPress={()=>this.props.history.replace(nav.path)}
  				tabBarPosition="bottom"></Item>
  				)
  			)
  		}</TabBar>)
  	}
  }
  
  //内部会向组件中传入一些路由组件特有的属性：history/location/math
  export default withRouter(NavFooter); //向外暴露withRouter()包装产生的组件
  ```

  main中保存了四个二级路由，但有一个组件需要被动态隐藏。给其中一个组件添加隐藏信息。哪个组件被隐藏根据用户类型决定。如果当前用户类型是“laoban”，那么就隐藏“dashen”组件。

  nav-footer.jsx组件用withRouter包装并导出，可用props接收父组件的属性

  ```javascript
  //nav-footer.jsx
  
  let { navList } = this.props; //从父组件当中获取navList
  //过滤掉hide为true的nav
  navList = navList.filter(nav => !nav.hide)
  ```

## 个人中心功能页面的编写：

containers/personal/personal.jsx

- 使用antd-mobile里的UI组件

  ```javascript
  import { Result, List, Button, WhiteSpace } from "antd-mobile";
  ```

- 用connect将组件包装成容器组件

  ```javascript
  export default connect(
  	state => ({user: state.user}),
  	{}
  	)(Personal);
  ```

- 页面结构：

  ```javascript
  class Personal extends Component{
  	render(){
  		const { username, header, company, post, salary, info } = this.props.user
  		return (
  			<div>
  				<Result 
  					img={<img src={require(`../../assets/images/${header}.png`)} style={{width:50}} alt="header"/>} title={username} message={company} />
  				<List renderHeader={ ()=> "相关信息" }>
  					<Item multipleLine> 
  						<Brief>职位：{post}</Brief>
  						<Brief>简介：{info}</Brief>
  						{salary ? <Brief>薪资：{salary}</Brief> : null}
  					</Item>
  				</List>
  				<WhiteSpace/>
  				<List>
  					<Button type="warning">退出登录</Button>
  				</List>
  			</div>)
  	}
  }
  ```

- 退出登录功能的编写

  ```
  <Button type="warning" onClick={this.loginOut}>退出登录</Button>
  ```

  ❌：点击“退出”按钮时，按钮没有样式上的任何反应。

  📓：原因是底部导航的高度100%，覆盖了整个页面。导致点击不到退出按钮。

  📒：解决办法：需要修改assets/css/index.less文件里的`.am-tab-bar`样式，设置`height:inherit;`

- 要实现点击“退出登录”按钮，跳出确认框，跳转到登陆界面上的功能，需要一个对话框组件：Modal。Modal组件由antd-mobile提供，它是一个对象，不是一个标签。Modal组件有一个alert方法，接收三个参数，Modal.alert("退出", "确认退出登录吗？", [{},{}])，前两个是描述，第三个是一个数组，数组第一个元素描述第一个按钮，第二个元素描述第二个按钮。

- 如果不需要跟后台通信，那么就用同步action。resetuser可以使用户状态回到初始状态。

  ```javascript
  logOut = ()=>{
  		Modal.alert("退出", "确认退出登录吗？", [
  			{
  				text: "取消",
  			},
  			{
  				text: "确认",
  				onPress : ()=>{
  					//移除cookie中的userid
  					Cookies.remove("userid");
  					//移除redux里管理的userid
  					this.props.resetUser()
  				}
  			}])
  	}
  ```

✅：“个人中心”路由界面的代码编写完成

## 老板/大神列表功能的编写

containers/laoban/laoban.jsx; 

#### containers/dashen/dashen.jsx 

两个列表功能类似，可以抽取出一个组件，用来展示相同的结构。只要根据类别往里面填充不同功能就可以了。因此我们创建一个用户列表组件：components/user-list/user-list.jsx

- 需要编写展示大神/老板列表的静态UI组件。需求：从后台获取指定用户类型的列表，渲染到页面上

- 首先编写后台路由routes/index.js

- ```javascript
  //根据type获取对应的用户列表
  router.get('/userlist',function(req,res){
  	const { type } = req.query;
  	UserModel.find({type}, filter, function(error, users){
  		res.send({code: 0, data: users});
  	})
  })
  ```

- 后台路由编写好之后，在postman进行接口的调试。选择“GET”类型，“params”类型进行测试。

  ✅：展示大神/老板列表的后台路由接口编写完成，功能为根据type获取对应的用户列表

  ------

- 前台api的编写。根据接口文档去定义接口请求函数

  ```javascript
  //src/api/index.js
  export const reqUserList = (type)=> ajax("/userlist", {type}, "GET");//请求方式为"GET"时可省略
  ```

- userList需要用redux进行管理，因此需要编写redux

  ```javascript
  //action-types
  export const RECEIVE_USER_LIST = "receive_user_list";
  //之前的action都是在操作user，此action是操作user-list 的，因此需要定义对应的reducer
  ```

  ```javascript
  //reducer
  //产生userlist状态的reducer
  //通过dispatch对应的action来修改状态，而状态的修改统一通过reducer来完成。
  const initUserList = []
  function userList(state=initUserList, action){
  	switch(action.type){
  		case REVEIVE_USER_LIST: //data为userList
        return action.data
  		default:
  		return state
  	}
  }
  ```

  ```javascript
  //action
  
  //接收用户列表的同步action
  export const receiveUserList = (userList)=>({type: REVEIVE_USER_LIST, data: userList});
  
  //获取用户列表的异步action
  export const getUserList = (type)=>{
  	return async dispatch =>{
  		//执行异步ajax请求
  		const response = await reqUserList(type) //reqUserList是一个ajax请求
  		const result = response.data;//response是一个对象，格式为{code: 0, data: users}
  		//得到结果之后分发一个同步action
  		if (result.code === 0) {
  			dispatch(receiveUserList(result.data));
  		}
  	}
  }
  ```

  ✅：获取用户列表的redux部分代码完成

  ------

  ### 【2019-8-4 09:09:00】

  项目打开流程：

  ```
  数据库mongodb，执行mongod命令；
  后端应用项目，执行 npm start 命令
  前端应用项目，执行 npm start 命令
  ```

- 两个用户列表组件：老板/大神，根据type定义不同列表。但是列表结构是一样的，所以可以抽象成一个组件。

  - 新建componnets/users-list/user-list.jsx

    ```javascript
    //显示指定用户列表的UI组件
    //需要接收一个user-list对象
    import React, { Component } from "react";
    // import { connect } from "react-redux";
    import PropTypes from "prop-types";
    import { WingBlank, Card, WhiteSpace } from "antd-mobile";
    const Header = Card.Header;
    const Body = Card.Body;
    
    export default class UserList extends Component{
    	static propTypes = {
    		userList: PropTypes.array.isRequired //接收一个userList
    	}
    	render(){
    		const { userList } =this.props;
    		return (
    			<WingBlank>
    			{ userList.map(user =>(
    				<div key={user._id}>
    					<WhiteSpace />
    
    					<Card>
    						<Header thumb={require(`../../assets/images/${user.header}.png`)} extra="username"></Header>
    						<Body>
    							<div>职位：{user.post}</div>
    							{user.company ? <div>公司：{user.company}</div> : null}
    							{user.salary ? <div>月薪：{user.salary}</div> : null}
    							<div>描述：{user.info}</div>
    						</Body>
    					</Card>
    				</div>
    				)
    			)}
    			</WingBlank>
    			)
    	}
    }
    ```

    渲染界面的时候遇到bug：![Snip20190804_2](/Users/luofei/Pictures/Snip20190804_2.png)

报错：![Snip20190804_3](/Users/luofei/Pictures/Snip20190804_3.png)

最后发现是在api/ajax.js文件中的substring方法拼写错误，写成了subString了。

【2019-8-4 13:20:00】

✅ bug修复

### 完善列表页面显示:

❌：最后一行的显示会被底部导航栏挡住。

📓：给列表所在tag加style：

```html
<WingBlank style={{marginBottom: 50}}>
```

❌头部会随着页面滚动而滚动，我们需要它固定.加style={{marginBottm:50, marginTop:50}}即可解决问题

✅： 信息列表完成

### 实现实时聊天功能

1. 下载相关依赖包：前台应用和后台应用都需要下载

   ```
   $ sudo cnpm install socket.io -S
   ```

   - 这是一个能实现多人远程实时通信【聊天】的库;

   - 它包装的是**H5 WebSocket**【使用的是ws协议，语法ws://。http协议只能客户端发起请求，不能实现服务器向浏览器发送请求。ws协议可以实现客户端和服务端互相发送请求】和**轮询**【浏览器每隔一段时间向服务器发送请求】, 如果是较新的浏览器内部使用WebSocket。

     如果浏览器不支持, 那内部就会使用轮询实现实时通信 

   - socket.io包含两个包，一个用于服务器端的包，就叫做socket.io；一个用于客户端的包，叫做socket.io-client

2.  服务器端创建一个测试文件socketIO/test.js

   服务器端的io是全局的，io.emit信息发送给所有连接上服务器的客户端；socket.emit信息发送给当前socket对应的客户端

   ```javascript
   //   /socketIO/test.js
   module.exports = function (server){
   	//得到IO对象
   	const io = require('socket.io')(server); //引用socket.io库，执行server函数得到io
   	//见识连接（当有一个客户连接上时回调）
   	io.on('connection', function(socket){ //这里的on表示连接任何浏览器：客户端产生连接的时候执行回调函数
   		console.log('socketio connected');
   		//绑定sendMsg监听，接收客户端发送的消息
   		socket.on('sendMsg', function(data){ //连接的是当前socket对应的客户端。这里的sendMsg可以任意命名
   			console.log('服务器接收到浏览器的消息', data);
   			//向客户端发送消息（名称，数据）
   			io.emit('receiveMsg', data.name+'_'+data.data);//发送给所有连接上服务器的客户端
   			//socket.emit('receiveMsg', data.name+'_'+data.data) 发送给当前socket对应的客户端
         console.log('服务器向浏览器发送消息',data);
   		})
   	})
   }
   
   //这是一个函数类型的模块
   ```

3. 服务端的bin/www文件下：

   ```
   //是一个函数类型
   require('../socketIO/test')(server);// 加载刚才定义的模块。这是一个函数类型
   ```

4. 客户端 src/test/socketio_test.js

   ```javascript
   //此模块没有向外暴露什么，执行它就行了，要想让它执行，可以引入到入口js文件上
   import io from "socket.io-client"; 
   
   const socket = io('ws://localhost:4000');//连接指定的服务器端，
   socket.on('receiveMsg', function(data){//绑定监听，接收数据，数据从服务器端发过来
   	console.log('浏览器端接收到消息',data);
   });
   
   socket.emit('sendMsg', {name: 'Tom', data: Date.now()});//emit分发消息
   console.log('浏览器端向服务器发送消息:', {name: 'Tom', data:Date.now()})
   ```

5. socketio_test模块没有向外暴露，因此想要执行，可以直接在入口js文件里引用。入口js文件加载所有相关的模块

   ```javascript
   //src/index.js
   import "./test/socketio_test";
   ```

### 【2019-8-5 08:30:00 】从第52节：socketio的介绍和理解开始。

今日计划【P52-P62】

1. 服务器端代码：

   ```javascript
   //socketIO/test.js
   
    //此处的server是bin/www中声明的，var server = http.createServer(app);
   
   module.exports = function(server){
   	const io = require('socket.io')(server);
   	//监视客户端与服务器的链接
   	io.on('connection',function(socket){
   		console.log('有一个客户端连接上了服务器。')
   	
   		//绑定监听，接收客户端发送过来的数据，并且处理数据
   		socket.on('sendMsg', function(data){
   			console.log('服务器接收到客户端发送的消息,',data)
   			data.name = data.name.toUpperCase(); //服务器处理客户端发过来的数据
   			socket.emit('receiveMsg',data) //服务器向客户端发送消息,data是处理过后的数据
   		// io.emit('receiveMsg',data) 也可以用io.emit来向客户端分发消息
   		console.log('服务器向客户端发送消息',data)
   		});
   	})
   }
   ```

   ```javascript
   // bin/www
   
   require('../socketIO/test')(server)//此处得到的是函数，因此(server)执行它，并传入参数server
   ```

2. 客户端代码

   ```javascript
   //  src/test/socketio_test.js
   
   //此模块没有向外暴露什么，执行它就行了，要想让它执行，可以引入到入口js文件上
   import io from "socket.io-client";
   
   //连接服务器，得到与服务器的链接对象
   
   const socket = io('ws://localhost:4000');
   
   //发送消息
   socket.emit('sendMsg',{name: "abc"})  //第二个参数只要是js支持的数据类型都可以
   //客户端发送消息，消息名为sendMsg，发送的内容是一个对象。此时需要服务器端来接受，需要设计服务器端的代码-->
   //写完服务器的代码后，回过来写客户端的代码
   console.log('客户端向服务器发消息', {name: "abc"})
   //绑定监听，接收服务器发送的消息
   socket.on("receiveMsg", function(data){
   	console.log('客户端接收到服务器发送的消息',data)
   })
   ```

   ```javascript
   //. src/index.js
   
   import "./test/socketio_test"; //项目入口文件引入
   ```

   此时在服务器端文件夹下执行npm start，客户端文件夹下npm start，服务器端终端显示成功连接

✅：基础功能测试

进行聊天界面的代码编写：

1. 聊天组件功能：chat.jsx

2. 消息列表：message.jsx.聊天消息需要用数据库进行存储

3. 未读消息显示，包括总数量的显示

   - 数据库的代码：

     ```javascript
     //服务器端/db/models.js
     
     //定义chat集合的文档结构：基于schema结构定义数据模型
     const chatSchema = mongoose.Schema({
     	from: {type: String, required: true}, //发送用户的id
     	to: {type: String, required:true}, //接收用户的id
     	chat_id: {type: String, required:true}, //聊天的一对一连接，是from和to组成的字符串。1发给2和2发给1应该是一样的值。
     	content: {type:String, required: true}, //内容
     	read: {type: Boolean, default: false}, //标识是否已读
     	create_time: {type: Number} //创建时间。和不同的人聊天有排序，这个排序由这个字段存储
     });
     //定义能操作chat集合数据的Model
     const ChatModel = mongoose.model('chat',chatSchema);
     //向外暴露ChatModel
     exports.ChatModel = ChatModel
     ```

     ✅： 数据库部分代码完成

   - 新增两个路由接口：routes/index.js

     ```JavaScript
     //服务器端：routes/index.js
     
     const { UserModel, ChatModel } = require("../db/models"); 
     
     //获取当前用户所有相关聊天信息列表
     /*返回的数据包括code、data两个属性；data包括"users"和"chatMsgs",
     其中users是对象{_id1:{},_id2:{},_id3:{}...}，使用对象的优点是可以根据对象属性名立刻得到属性值。
     chatMsgs是数组[{},{}]*/
     router.get('/msglist',function(req,res){ 
     	const userid = req.cookies.userid;//查询得到所有的user文档数组
     	UserModel.find(function(err,userDocs){
     		//用对象存储所有user信息：key为user的_id，val为name和header组成的user对象
     		// const users = {};
     		// userDocs.forEach(doc => {
     		// 	users[doc._id] = {username: doc.username, header:doc.header}
     		// })
     		//可以用数组的递归写法,进行累加
     		const users = userDocs.reduce((users,user) => {
     			users[user._id] = {username: user.username, header: user.header}
     			return users;
     		}, {})
     
     		/*查询userid相关的所有聊天信息：
     		参数1: 查询条件
     		参数2: 过滤条件
     		参数3: 回调函数
     		*/
     		ChatModel.find({'$or':[{from: userid}, {to: userid}]}, filter, function(error,chatMsgs){
     			res.send({code:0, data:{users, chatMsgs}}) //data的值是一个对象，此对象有两个属性，一个users是对象类型，一个chatMsgs是数组类型
     		})
     		//此处的"$or"表示查询条件是from: userid或者to: userid;filter表示过滤掉password；chatMsgs表示得到聊天消息的数组
     	})
     })
     
     
     //修改指定消息为已读
     router.post('/readmsg',function(req,res){ //需要修改数据库的数据。所有用post请求
     	//得到请求中的from和to
     	const from = req.body.from; //对方发送数据
     	const to = req.cookies.userid; //要修改的是对方发过来的消息显示已读，所以从cookies里提取自己的userid
     	/*更新数据库中的chat数据
     	参数1: 查询条件
     	参数2: 更新为指定的数据对象
     	参数3: 是否1次更新多条，默认值更新一条
     	参数4: 更新完成的回调函数*/
     	ChatModel.update({from, to, read:false}, {read:true}, {multi:true}, function(err,doc){
     		// update默认将查询结果只更新一次，如果查询到多条匹配项，只更新一条。{multi:true}指定所有匹配项都执行更新操作。
     	console.log('/readMsg', doc);
     	res.send({code:0, data: doc.nModified}); //doc有一个nModified属性，表示更新的数量
     	})
     })
     ```

     ✅：后台路由接口routes/index.js完成，注册了【获取当前用户所有相关聊天信息列表】和【修改指定消息为已读】两个路由

     写完后台路由接口之后，打开postman进行测试。此时还没有消息的收发，没有数据。可以等到有数据之后再测试。

   - 聊天界面的创建

     - 客户端注册聊天界面子路由：containers/main/main.jsx

     ```javascript
     // 客户端/containers/main/main.jsx
     
     import Chat from "../chat/chat";
     
     <Route path="/chat/:userid" component={Chat} />
     ```

     - 点击老板/大神列表【user-list】中的某一项，跳转到消息界面

     ```javascript
     //components/user-list/user-list.jsx
     <Card onClick={()=>this.props.history.push(`/chat/${user._id}`)}>
     ```

     程序报错：![Snip20190805_4](/Users/luofei/Pictures/Snip20190805_4.png)

     原因：user-list是非路由组件，需要用WithRouter包装：

     ```JavaScript
     import { withRouter } from "react-router-dom";
     
     export default withRouter(UserList)
     ```

     修改完之后运行成功。

聊天界面静态组件的编写：

```javascript
import '../../assets/css/index.less';

import React, {Component} from "react";
import { NavBar, List, InputItem } from "antd-mobile";
import '../../assets/css/index.less'

const Item = List.Item;

//聊天界面路由容器
export default class Chat extends Component{
	render(){
		return (
			<div id="chat-page">
				<NavBar>aa</NavBar>
				<List>
					<Item thumb={require(`../../assets/images/头像1.png`)}>你好</Item>
					<Item thumb={require(`../../assets/images/头像1.png`)}>你好2</Item>
					<Item className="chat-me" extra='我'>我很好</Item>
					<Item className="chat-me" extra='我'>我很好2</Item>
				</List>
				<div className="am-tab-bar">
				<InputItem placeholder="请输入" extra={<span>发送</span>} />
				</div>
			</div>
			)
	}
}
```

样式编写：

```css
#chat-page .chat-me .am-list-extra{
	flex-basis: auto;
}
#chat-page .chat-me .am-list-content{
	padding-right: 15px;
	text-align: right;
}
```

- 聊天界面动态组件的编写：

  - 发消息

    - 点击“发送”按钮，消息会被发送出去，对话框可以看到消息

    ```javascript
    //containers/chat/chat.jsx
    import { connect } from "react-redux";
    import {} from "../../redux/actions" //导入异步action
    
    	state = {
    		content: ''
    	}
    
    handleSend = ()=>{ //需要content、from、to三个信息
    		const from = this.props.user._id;
    		const to = this.props.match.params.userid;
    		const content = this.state.content.trim()
    		//发送请求（发消息）
    		if (content) {
    			this.props.sendMsg({from, to, content});
    		}
    		//清除输入数据
    		this.setState({content: ''})
    	}
    
    <InputItem 
    				placeholder="请输入" 
    				value={this.state.content}
    				onChange={val => this.setState({content: val})}
    				extra={<span onClick={this.handleSend}>发送</span>} />
    ```

    ```javascript
    //redux/actions.js
    
    //异步发送消息的异步action
    ```

### 【2019-8-5】 今天视频看至P57，下午电脑没电，手机上看了一点websoket、css调试的内容

### 【2019-8-6】 今天从P57开始看

```javascript
// src/test/socketio_test.js

//此模块没有向外暴露什么，执行它就行了，要想让它执行，可以引入到入口js文件上
import io from "socket.io-client";

//连接服务器，得到与服务器的链接对象
const socket = io('ws://localhost:4000');
//绑定监听，接收服务器发送的消息
socket.on("receiveMsg", function(data){
	console.log('客户端接收到服务器发送的消息',data)
})

//发送消息
socket.emit('sendMsg',{name: "abc"})  //第二个参数只要是js支持的数据类型都可以
//客户端发送消息，消息名为sendMsg，发送的内容是一个对象。此时需要服务器端来接受，需要设计服务器端的代码-->
//写完服务器的代码后，回过来写客户端的代码
console.log('客户端向服务器发消息', {name: "abc"})

```

```javascript
// src/redux/action/actions.js

import io from "socket.io-client"; //在actions里引入io
```

```javascript
//socketio_test.js中的代码:

//连接服务器，得到与服务器的链接对象
const socket = io('ws://localhost:4000');
//绑定监听，接收服务器发送的消息
socket.on("receiveMsg", function(data){
	console.log('客户端接收到服务器发送的消息',data)
}) //这段代码只需做一次就够了，因此可以把它封装成一个函数

上述代码只需执行一次，因此可以把它在actions里封装成一个函数
⬇️


// src/redux/actions.js
function initIO(){
	//连接服务器，得到与服务器的链接对象
	const socket = io('ws://localhost:4000');
	//绑定监听，接收服务器发送的消息
	socket.on("receiveMsg", function(data){
		console.log('客户端接收到服务器发送的消息',data)
	}) //这段代码只需做一次就够了，因此可以把它封装成一个函数
}

//异步发送消息的异步action
export const sendMsg = ({from, to, content}) => {
	return dispatch => {
		console.log('发送消息', {from, to, content})
	}
}
```

此时如果要在异步action里调用initIO()，会导致initIO()被调用多次。而我们希望initIO()里的socket只被创建一次。因此这里可以用单例对象：只产生一个的实例对象。

- 单例对象：

  - 创建对象之前，判断对象是否已经创建。只有对象还没有创建的才去创建

  - 创建对象之后，保存对象。这里的对象是socket。

  - ```javascript
    // src/redux/actions.js
    function initIO(){
    	if (!io.socket) {
    		io.socket = io('ws://localhost:4000');//连接服务器，得到与服务器的链接对象.创建该对象之后，保存对象
    		io.socket.on("receiveMsg", function(data){//绑定监听，接收服务器发送的消息
    		console.log('客户端接收到服务器发送的消息',data)
    		}) //这段代码只需做一次就够了，因此可以把它封装成一个函数
    	}
    }
    
    //异步发送消息的异步action
    export const sendMsg = ({from, to, content}) => {
    	return dispatch => {
    		console.log('发送消息', {from, to, content});
    		initIO()
    	}
    }
    ```

  服务器端创建socketIO_server.js文件：

  ```javascript
  //要处理数据，需要引用mongodb数据库的Model模块
   //此处的server是bin/www中声明的，var server = http.createServer(app);
  //引入对数据的处理模块Model：
  const { ChatModel } =require("../db/models")
  
  module.exports = function(server){
  	const io = require('socket.io')(server);
  	//监视客户端与服务器的链接
  	io.on('connection',function(socket){
  		console.log('有一个客户端连接上了服务器。')
  	
  		//绑定监听，接收客户端发送过来的数据，并且处理数据
  		socket.on('sendMsg', function({from, to, content}){
  			//处理数据【保存消息】
  			//准备chatmessage对象的相关数据
  			const chat_id = [from, to].sort().join('_') //希望from_to或者to_from的结果一样。可以用排序。两个字符串的排序结果一致
  			const create_time = Date.now() //创建对话的事件
  			new ChatModel({from, to, content, chat_id, create_time}).save(function(error, chatMsg){
  				 io.emit('receiveMsg',chatMsg) //用io表示向所有连接的客户端发送消息。效率不高，但简单。然后再从浏览器端屏蔽掉和自己无关的消息
  			//此处发送的是chatMsg，那么客户端actions.js里的initIO()- - >io.socket.on()里的函数接收的也应该是chatMsg
  			})
  			
  		});
  	})
  }
  ```

  更正bin/www里的引用：

  ```javascript
  require('../socketIO/socketIO_server.js')(server)//此处得到的是函数，因此(server)执行它，并传入参数server
  ```

  ✅：后台接口/聊天静态组件/发送消息与介绍消息的功能

  postman里做“获取当前用户相关的所有聊天消息”的接口测试，不需要输入参数，直接send。

  接下来task：获取消息列表显示：

  1. 前台：src/api/index

     ```javascript
     //获取当前用户的聊天信息列表
     export const reqChatMsgList = () =>ajax("/msglist");
     
     //修改指定消息为已读
     export const reqReadMsg = (from)=>ajax('/readmsg', {from}, 'POST')
     ```

  2. src/redux/reducers.js

     ```javascript
     import { 
     	AUTH_SUCCESS, 
     	ERROR_MSG, 
     	RECEIVE_USER, 
     	RESET_USER, 
     	RECEIVE_USER_LIST,
     	RECEIVE_MSG_LIST,
     	RECEIVE_MSG
     	  } from "./action-types";
     
     //产生聊天状态的reducer
     const initChat = {
     	users: {}, //包含所有用户信息的对象；属性名：userid，属性值是：{username,header}
     	chatMsgs: [], //当前用户所有message相关的数组
     	unReadCount: 0 //总的未读数量
     }
     function chat(state=initChat, action){
     	switch(action.type){
     		case RECEIVE_MSG_LIST: //data: {users, chatMsgs}
     		const { users, chatMsgs } = action.data;
     		return  {
     			users,
     			chatMsgs,
     			unReadCount: 0
     		}//return的结构必须是上述initChat的结构
     		case RECEIVE_MSG:
     		return 
     		default:
     		return state;
     	}
     }
     export default combineReducers({ user, userList, chat });
     ```

     src/redux/action-type.js

     ```javascript
     export const RECEIVE_MSG_LIST = "receive_msg_list"; ////接收所有相关消息列表
     export const RECEIVE_MSG = "receive_msg"; //接收一条消息
     ```

     用户登录账号，就获得消息列表，而不是必须通过user-list才能获取。判断用户登录的条件：用户登录login；用户注册register；获取到用户信息getUser

     ```javascript
     //  src/redux/actions.js
     
     function initIO(){
     	if (!io.socket) {
     		io.socket = io('ws://localhost:4000');//连接服务器，得到与服务器的链接对象.创建该对象之后，保存对象
     		io.socket.on("receiveMsg", function(chatMsg){//绑定监听，接收服务器发送的消息
     			console.log('客户端接收到服务器发送的消息',chatMsg)
     		}) //这段代码只需做一次就够了，因此可以把它封装成一个函数
     	}
     }
     //获取消息列表数据的函数
     async function getMsgList(dispatch){
     	initIO(); //连接服务器获取消息应该在getMsgList之前做
     	const response = await reqChatMsgList();
     	const result = response.data;
     	if (result.code === 0) {
     		const { users, chatMsg } = result.data;
     		//分发一个同步action
     		dispatch(receiveMsgList({ users, chatMsg }))
     	}
     }
     ```

     至P59，出现的问题：chrome后台的redux里，chatMsgs没有内容，是一个空数组。可能是没有传值

- 显示某个聊天信息列表

  ```javascript
  //containers/chat/chat.jsx
  render(){
      const { user } = this.props;
  		const { users, chatMsgs } = this.props.chat //此处chatMsgs 包含的是“我”和所有列表用户的聊天记录，而需要的只是和当前用户的聊天记录，因此需要对chatMsgs进行过滤，过滤根据chat_id来过滤
  		
  		//计算当前聊天的chat_id
  		const meId = user._id; //用户端的id
  		const targetId = this.props.match.params.userid //当前目标的id
  		const chatId = [targetId, meId].sort().join('_')
  
  		//对chatMsg进行过滤
  		const msgs = chatMsgs.filter(msg => msg.chat_id === chatId);
  		
  		//得到目标用户头像header图片对象
  		const targetHeader = users[targetId].header;
  		const targetIcon = targetHeader ? require(`../../assets/images/${targetHeader}.png`) : null;
    
    return (
    ...
      <List>
  				{msgs.map(msg => {
  					if (targetId === msg.from) { //对方发消息过来,返回左边的标签
  						return <Item key={msg._id} thumb={targetIcon} >{msg.content}</Item>//头像只需要加载一次就行了
  					}else{ //此端发消息,返回右边的标签
  						return <Item key={msg._id} className="chat-me" extra='我'>{msg.content}</Item>
  					}
  				})}
  				</List>
    )
  }
  
  export default connect(
  	state => ({user: state.user, chat:state.chat}),
  	{sendMsg}
  	)(Chat)
  ```

  以上代码运行报错：

  ![Snip20190806_5](/Users/luofei/Pictures/Snip20190806_5.png)

原因：`const targetHeader = users[targetId].header;`里的users此时是一个空对象，需要在用到users之前做一个判断，判断数据是否已经获取到。

```javascript
if (!users[meId]) {//如果还没有获取到数据，就不做任何显示。users一定用户值，chatMsgs可能没值
			return null
		}
```

❌报错：

![Snip20190807_1](/Users/luofei/Pictures/Snip20190807_1.png)

还没找到原因。先继续往下看。

✅：找到原因：

```javascript
//redux/reducers.js

case RECEIVE_MSG: //返回的data是chatMsg
			const chatMsg = action.data; //之前这里的chatMsg写了{}，导致运行报错。什么时候该加{}，什么时候不加？？
			return {
				users: state.users,
				chatMsgs: [...state.chatMsgs, chatMsg],
				unReadCount: 0
			}
```

`const chatMsg = action.data`是取出传过来的数据，就是chatMsg。

 此时的“老板”和“大神”可以进行对话了，但是从控制台可以看到，老板A给大神A发送的消息，其它所有账号都能收到，只不过没有显示在页面上。

【2019-8-7 11:10:00】P61

###  添加表情功能

一个表情实际上就是一个字符文本，可以直接用字符串显示。表情字符提供的网站：[https://emojipedia.org](https://emojipedia.org)

可以直接复制

```javascript
// containers/chat.jsx

<InputItem 
				placeholder="请输入" 
				value={this.state.content}
				onChange={val => this.setState({content: val})}
				extra={
					<span>Grinning Face</span>
					<span onClick={this.handleSend}>发送</span>} />
```

此处需要注意的是，extra必须要有一个跟标签进行包裹。⬇️

```javascript
// containers/chat.jsx

<InputItem 
				placeholder="请输入" 
				value={this.state.content}
				onChange={val => this.setState({content: val})}
				extra={
          <span>
              <span>Grinning Face</span>
              <span onClick={this.handleSend}>发送</span>
          </span> } />
```

接下来实现功能：点击表情，出现一个网格列表，并且列表中的表情元素可选。不需要的时候列表隐藏.代码编写顺序：

- 放置表情位置：InputItem的extra属性里面；注意extra里的元素需要一个跟标签进行包裹。

- 设置表情网格显示状态：`state: {isShow: false}`
- 引入antd-mobile的Grid组件，使用该组件的data、columnNum、carouselMaxRow，isCarousel、onClick属性
- 引入表情数据数组，该数组需要提前准备好。可以放在componentWillMount()函数里面，该函数在第一次render执行之前执行
- 点击输入框右边的表情时，切换表情网格的显示/隐藏

```javascript
//containers/chat.jsx

state = {
		content: '',
		isShow: false //是否显示表情列表
	}
···

componentWillMount(){ //在第一次render执行之前回调，在此初始化表情列表数据
		const emojis = ['😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗', '😚', 
		'😙','😋', '😛','😝', '🤑', '🤗','🤭', '🤫','🤔', '🤐','🤨','😐','😑',
		'😶','😏','😒','🙄','😬','🤥','🤒', '🤕','🤢','🤮','🤧','🥵','🥶','🥴',
		'😵','🤯', '🤠','🥳'] //要求该数组里的元素是对象，对象有一个text属性，text属性的值是表情。
		this.emojis = emojis.map(emoji => ({text: emoji}))
	}

toggleShow =()=>{
		const isShow = !this.state.isShow; //切换状态，即对当前状态取反、
		this.setState({isShow});
		if (isShow) {
			//异步手动派发resize事件，解决表情列表显示的bug
			setTimeout(() => {
				window.dispatchEvent(new Event('resize'))
			}, 0);
		} 
	}

...

<InputItem 
				placeholder="请输入" 
				value={this.state.content}
				onChange={val => this.setState({content: val})}
				extra={
					<span>
						<span onClick={this.toggleShow}>😍</span>
						<span onClick={this.handleSend}>发送</span>
					</span>} 
					/>
					{this.state.isShow ? (<Grid 
						data={this.emojis} //data是一个数组，含有icon、text两个属性
						columnNum={8}
						carouselMaxRow={4}
						isCarousel={true}
						onClick={(item) => {this.setState({content: this.state.content + item.text})}}/>) : null}
				
```

```javascript
//点击发送，表情框隐藏：

handleSend = ()=>{ //需要content、from、to三个信息
		const from = this.props.user._id;
		const to = this.props.match.params.userid;
		const content = this.state.content.trim()
		//发送请求（发消息）
		if (content) {
			this.props.sendMsg({from, to, content});
		}
		//清除输入数据
		this.setState({
			content: '',
			isShow: false})
	}

extra={
        <span>
          <span onClick={this.toggleShow}>😍</span>
          <span onClick={this.handleSend}>发送</span>
        </span>} 
```

✅  表情框代码完毕。

### 固定标题栏；实现聊天界面滑动

1. 固定标题栏

```javascript
<NavBar className="sticky-header">{users[targetId].username}</NavBar>
<List style={{marginTop:50, marginBottom:50}}>
```

2. 实现界面左上角返回：

```javascript
<NavBar 
				icon={<Icon type="left"/>} 
				className="sticky-header"
				onLeftClick={()=>this.props.history.goback()} //点击返回按钮，执行回调函数
				>{users[targetId].username}</NavBar>
```

3. 点击到该界面时，页面滑动到底部;消息发送成功时，聊天界面也滑动到底部。

```javascript
componentDidMount(){
		window.scrollTo(0, document.body.scrollHeight);//初始化显示聊天列表，使页面滑动到底部
	}
componentDidUpdate(){
  window.scrollTo(0, document.body.scrollHeight); //更新显示列表
}
```

### 显示消息列表

1. 消息列表静态组件

   ```javascript
   //containers/messages/messages.jsx
   return (
   			<List style={{marginTop: 50}}>
   				<Item 
   				extra={<Badge text={3} />}
   				thumb={require(`../../assets/images/头像1.png`)} 
   				arrow="horizontal">
   				你好
   				<Brief>nr1</Brief>
   				</Item>
   				<Item 
   				extra={<Badge text={1} />}
   				thumb={require(`../../assets/images/头像2.png`)} 
   				arrow="horizontal">
   				你好2
   				<Brief>nr2</Brief>
   				</Item>
   			</List>
   			)
   ```

2. 传入数据，进行聊天信息的分组

   ```javascript
   export default connect(
   	state => ({user:state.user, chat:state.chat}), //需要的数据：当前用户名，当前聊天信息
   	{}
   	)(Message)
   ```

3. 功能函数：根据与某个人聊天的chat_id,对chatMsgs进行分组

   ```javascript
   function getLastMsgs(chatMsgs){
   	//功能函数：根据与某个人聊天的chat_id,对chatMsgs进行分组，
   	//得到每个组的lastMsg组成的数组
   	//1.找出每个聊天的lastMsg，并用一个对象容器来保存{chat_id:lastMsg}
   	const lastMsgObjs = {} //准备一个空容器
   	chatMsgs.forEach(msg => {
   		const chatId = msg.chat_id; //得到msg聊天标识id
   		const lastMsg = lastMsgObjs[chatId];//获取已保存的当前组件的lastMsg
   		if (!lastMsg) {//当前msg就是所在组的lastMsg
   			lastMsgObjs[chatId] = msg
   		}else{//如果msg比lastMsg晚，就讲msg保存为lastMsg
   			if (msg.create_time > lastMsg.create_time) {
   				lastMsgObjs[chatId] = msg; //将msg赋值给lastMsg之后，要关联到lastMsgObjs中
   
   			}else{}
   		}
   	})
     
   	//2.得到所有lastMsg的数组
   	const lastMsgs = Object.values(lastMsgObjs)//values返回的数组指定是哪个对象
   	
     //3.对数组根据create_time进行降序排序
   	lastMsgs.sort(function(m1,m2){//传入sort一个排序函数，如果结果小于0，将m1放在前面；为0顺序不变；大于0m2在前面
   		return  m2.create_time - m1.create_time; //如果此值小于0，那么m1在前面
   	})
   	return lastMsgs
   }
   
   
   
   render(){
   		const { user } = this.props;
   		const { users, chatMsgs } =this.props.chat;
   		const lastMsgs = getLastMsgs(chatMsgs) //调用对chatMsgs进行分组的函数
   ```

   在render函数里面渲染到界面上：

   ```javascript
   const lastMsgs = getLastMsgs(chatMsgs)
   		return (
   			<List style={{marginTop: 50}}>
   			{
   				lastMsgs.map(msg => {
   					const targetUser = msg.to === user._id ? users[msg.from] : users[msg.to]
   					return (
   					<Item 
   						key={msg._id}
   						extra={<Badge text={0} />}
   						thumb={targetUser.header ? require(`../../assets/images/${targetUser.header}.png`) : null} 
   						arrow="horizontal">
   						{msg.content}
   						<Brief>{targetUser.username}</Brief>
   					</Item>
   					)
   				})
   			}
   			</List>
   			)
   ```

✅：聊天消息列表

### 点击消息列表的某一项，进入聊天界面

```javascript
  return (
    <List style={{marginTop: 50}}>
    {
      lastMsgs.map(msg => {
        //得到目标用户id
        const targetUserId = msg.to === user._id ? msg.from : msg.to;
        //得到目标用户的信息
        const targetUser = users[targetUserId]
        return (
        <Item 
          key={msg._id}
          extra={<Badge text={0} />}
          thumb={targetUser.header ? require(`../../assets/images/${targetUser.header}.png`) : null} 
          arrow="horizontal"
          onClick={ ()=> this.props.history.push(`/chat/${targetUserId}`)}>
          {msg.content}
          <Brief>{targetUser.username}</Brief>
        </Item>
        )
      })
    }
    </List>
    )
```

✅：功能完成

显示消息列表的未读数量，包括每一行的未读数量和总的未读数量

1. 设计一个属性unReadCount，将此msg的属性通过Item里的extra属性显示出来

```javascript
<Item 
      key={msg._id}

      extra={<Badge text={msg.unReadCount} />}
      
      thumb={targetUser.header ? require(`../../assets/images/${targetUser.header}.png`) : null} 
      arrow="horizontal"
      onClick={ ()=> this.props.history.push(`/chat/${targetUserId}`)}>
      {msg.content}
      <Brief>{targetUser.username}</Brief>
</Item>
```

2. 在统计lastMsgs的过程中，统计unReadCount

```javascript
chatMsgs.forEach(msg => {
		//往msg上加unReadCount属性。unReadCount是别人发给“我”的未读消息
		
		//对msg进行个体的统计，看这个个体是不是未读消息。
		if (msg.to === userid && !msg.read) {
			msg.unReadCount = 1
		}else{
			msg.unReadCount = 0
		}
  
  
if (!lastMsg) {//当前msg就是所在组的lastMsg
			lastMsgObjs[chatId] = msg
		}else{//如果msg比lastMsg晚，就讲msg保存为lastMsg
			//累加unReadCount = 已经统计的 + 当前msg的
			const unReadCount = lastMsg.unReadCount + msg.unReadCount;
			if (msg.create_time > lastMsg.create_time) {
				lastMsgObjs[chatId] = msg; //将msg赋值给lastMsg之后，要关联到lastMsgObjs中
			}
			//累加unReadCount，并保存在最新的lastMsg上:lastMsgObjs[chatId]表示罪行的lastMsg
			lastMsgObjs[chatId].unReadCount = unReadCount
		}
  
  //函数传入参数：
  function getLastMsgs(chatMsgs, userid){
    
  //在组件里调用时的参数：
  const lastMsgs = getLastMsgs(chatMsgs, user._id)
```

✅： 未读消息数量的显示

### 总的未读消息的显示

1. readucer.jsx文件里对unReadCount做统计

   - 接收消息列表的时候统计出来总的未读消息数量

     ```javascript
     // redux/reducers.jsx
     case RECEIVE_MSG_LIST: //data: {users, chatMsgs}
     			const { users, chatMsgs, userid } = action.data;
     			return  {
     				users,
     				chatMsgs,
     				unReadCount: chatMsgs.reduce((preTotal, msg) => preTotal + (!msg.read && msg.to===userid ? 1 : 0), 0)
     			}//return的结构必须是上述initChat的结构
     ```

   - 修改action.js里面的代码：

     ```javascript
     //function initIO(dispatch, userid)函数内部：
     dispatch(receiveMsg(chatMsg,userid));
     
     const receiveMsg = (chatMsg, userid)=> ({type: RECEIVE_MSG, data: {chatMsg, userid}})
     ```

   - 修改reducers.js里的引用

     ```javascript
     // redux/reducers.jsx
     case RECEIVE_MSG: //返回的data是chatMsg
     			const {chatMsg, userid} = action.data; //之前这里的chatMsg写了{}，导致运行报错。什么时候该加{}，什么时候不加？？
     			return {
     				users: state.users,
     				chatMsgs: [...state.chatMsgs, chatMsg],
     				unReadCount: state.unReadCount + (!chatMsg.read && chatMsg.to===userid ? 1 : 0) //判断是不是别人发给我的消息
     			}
     ```

   ❌ userid在两个case里重复声明的解决办法：不对第二个userid进行解构赋值，直接用action.data.userid来表示

   ```javascript
   reducers.js
   
   case RECEIVE_MSG: //返回的data是chatMsg
   			const {chatMsg} = action.data; //之前这里的chatMsg写了{}，导致运行报错。什么时候该加{}，什么时候不加？？
   			return {
   				users: state.users,
   				chatMsgs: [...state.chatMsgs, chatMsg],
   				unReadCount: state.unReadCount + (!chatMsg.read && chatMsg.to===action.data.userid ? 1 : 0) //判断是不是别人发给我的消息
   			}
   ```

2. 写好redux里的代码以后，在nav-footer/nav-footer.jsx里将其显示出来

```javascript
	static propTypes = {
		navList: PropTypes.array.isRequired;
    //将unReadCount的值传过来
		unReadCount: PropTypes.number.isRequired
	}

render(){
  //从this.props里获取unReadCount的值
		let { navList, unReadCount } = this.props;
  

<Item key={nav.path}
      badge={nav.path==="/message"?3:0} //这里的数字3要用unReadCount表示
      title={nav.text}
      icon={{uri:require(`./images/${nav.icon}.png`)}} 
      //第一层{}表示要写js表达式，第二层{}表示要写对象，``表示写的是一个模版字符串
      selectedIcon={{uri:require(`./images/${nav.icon}-selected.png`)}}
      selected={ path === nav.path}
      onPress={()=>this.props.history.replace(nav.path)}
      tabBarPosition="bottom"></Item>
```

1. 找出使用nav-footer.jsx组件的文件：containers/main/main.jsx里的<navFooter>组件，需要读取到unReadCount

```javascript
//containers/main/main.jsx

//如果有，读取redux中的user状态。读取unReadCount状态，用于底部未读信息的显示
const { user, unReadCount } = this.props;

{ currentNav ? <NavFooter navList={navList} unReadCount={unReadCount}/>: null} 
{/*底部导航单独抽取出来。*/}

export default connect(
	state => ({user: state.user, unReadCount: state.chat.unReadCount}),
	{ getUser } //将getUser传到当前的UI组件
	)(Main)
```

✅：统计底部总的未读消息数量

### 点击有未读消息，未读标志消失[更新未读数量]

- 点击消息列表项，进入聊天界面，就代表看了消息，此时可以更新未读消息数量为0
- 在chat.jsx组件里写，在componentDidMount()
- 在action里定义readMsg ，在action-type里定义MSG_READ
- 在action.jsx头部引入MSG_READ 
- 定义一个读取了某个聊天消息的同步action：msgRead
- 在reducers.js里引入该同步action：case: MSG_READ，并对符合条件的chatMsgs中的每一项进行处理
- 对方先发消息，而我后点进去，那么显示消息提示；

```javascript
// containers/chat.jsx

import { sendMsg,readMsg } from "../../redux/actions";

conponentDidMount(){
		...
		//发请求更新消息的未读状态
		const targetId = this.props.match.params.userid;
		this.props.readMsg(targetId) //读了消息，那么读了谁的消息？就需要知道目标：to
  //如果我先进入，对方后发，那么这段代码应该不执行。
	}

export default connect(
	state => ({user: state.user, chat:state.chat}),
	{sendMsg, readMsg}
	)(Chat)
```

```javascript
// redux/action.js
import { 
	MSG_READ //在action-type里定义之后，在这里引入
	} from "./action-types";

//读取消息的异步action
export const readMsg = (from, to) => {
	return async dispatch => { //不需要async/await了
		const response = await reqReadMsg(from);
		const result = response.data
		if (result.code === 0) {
			//去定义一个action-type
			const count = result.data //后台返回的
			dispatch(msgRead({count, from, to}))
		}
	}
}
//读取了某个聊天消息的同步action
const msgRead = ({count, from, to})=>({type: MSG_READ, data:{count, from, to}})
```

```javascript
// redux/reducers.js

import {MSG_READ} from "./action-types";

function chat(){
  ...
  case MSG_READ:
			const {from, to, count} = action.data;
			return {
				users: state.users,
				chatMsgs: [...state.chatMsgs, chatMsg],
				unReadCount: state.unReadCount - count				
			}
}
```

此时需要修改chatMsgs，找到某一些message，把read属性由false变成true

用数组的map方法。map方法不会改变数组原数据，而是产生一个新的数组

```javascript
// redux/reducers.js
case MSG_READ:
			const {from, to, count} = action.data;
			state.chatMsgs.forEach(msg =>{
				if (msg.from===from&&msg.to===to&!msg.read) {
					msg.read = true
				}
			})
			return {
				users: state.users,
				chatMsgs: state.chatMsgs.map(msg => {
					if (msg.from === from&&msg.to===to&&!msg.read) { //需要更新
						return {...msg, read: true}
					}else{//不需要更新
						return msg
					}
				}),
				unReadCount: state.unReadCount - count				
			}
```

添加一个componentWillUnmount()函数，用来清除卸载组件之前的数据，将componentwillUpdate函数里的相关代码复制过来。

```javascript
componentWillUnmount(){ //在退出聊天界面【也就是当前组件】之前执行
	//发请求更新消息的未读状态
		const from = this.props.match.params.userid;
		const to = this.props.user._id
		this.props.readMsg(from, to) //读了消息，那么读了谁的消息？就需要知道目标：to
	}
```

❌：这样处理的一个小小的问题：未读消息提示在退出界面的一瞬间会闪一下。

📓：这是由于要异步发送请求，请求过程中未读消息仍然会显示。

✅：更新未读消息数量

### 添加聊天的动画效果：切换页面，实现页面从上到下显示的效果

1. 加载库

   ```
   $ sudo cnpm install rc-queue-anim --save
   ```

2. 打开antd-mobile，底部的antd-motion - -> 动效组件 - ->进出场动画，查看效果

3. API - -> 进出场动画查看使用步骤

4. 在containers/chat/chat.jsx文件里引入该组件，并且设置属性，实现动画效果。

5. 聊天组件是通过List列表，map遍历返回多个Item的模式生成。而动画效果是通过<QueueAnim>标签将所有的列表项包裹起来。

   ```javascript
   import QueueAnim from 'rc-queue-anim';
   
   <List style={{marginTop:50, marginBottom:50}}>
       <QueueAnim>
       {/*alpha left right top bottom scale scaleBig scaleX scaleY*/}
         {msgs.map(msg => {
         if (targetId === msg.from) { //对方发消息过来,返回左边的标签
           return <Item key={msg._id} thumb={targetIcon} >{msg.content}</Item>//头像只需要加载一次就行了
         }else{ //此端发消息,返回右边的标签
           return <Item key={msg._id} className="chat-me" extra='我'>{msg.content}</Item>
         }
       })}
       </QueueAnim>
   </List>
   ```

   ✅：用antd-mobile的rc-queue-anim动画效果库完成组件的动画效果。引入的组件标签是<QueueAnim>,该组件可以使用type属性【动画类型】、delay属性【动画延迟效果】、duration属性【每一个动画的时间】等等。

   ❌：出现一个小问题：若是使用<QueueAnim>标签实现动画效果，那么在进入聊天页面的时候，无法定位到底部最新的消息处，而是停留在对话开始的地方。

   📓：解决办法：



